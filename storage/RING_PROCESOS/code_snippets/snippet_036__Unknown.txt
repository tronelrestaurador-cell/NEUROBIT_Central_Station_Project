python






















1



2



3



4





5



6



7





8





9



10



11



12





13



14



15





16





17



18



19





20



21





22



23



24



25





26



27



28



29



30



31



32



33



34





35



36



37



38



39



40



41



42





43



44



45





46



47



48



49



50



51



52



53



54





55





56



57



58



59



60





61



62



63



64



65



66





67



68



69





70



71



72



73





74



75



76



77



78



79



80

































































































































































































































































































































































































































































































































import yaml

import re

from pathlib import Path



class CoherenceFilter:

    """Valida coherencia según principios del Logos restaurado"""

    

    def __init__(self, config_path="config/system_vars.yaml"):

        with open(config_path, 'r') as f:

            self.config = yaml.safe_load(f)

        self.threshold = self.config['LOGOS_COHERENCE_THRESHOLD']['value']

    

    def validate_message(self, message_data):

        """Valida mensaje completo con metadatos NEUROBIT"""

        # Extraer contenido si viene en formato YAML

        if isinstance(message_data, str) and message_data.startswith("---"):

            try:

                msg_yaml = yaml.safe_load(message_data)

                content = msg_yaml.get('CONTENT', '')

            except:

                content = message_data

        else:

            content = message_data.get('CONTENT', message_data) if isinstance(message_data, dict) else message_data

        

        # Calcular puntuación de coherencia

        scores = {

            'logical': self._check_logical_consistency(content),

            'temporal': self._check_temporal_coherence(content),

            'semantic': self._check_semantic_density(content)

        }

        

        overall_score = sum(scores.values()) / len(scores)

        is_coherent = overall_score >= self.threshold

        

        return {

            'is_coherent': is_coherent,

            'score': overall_score,

            'threshold': self.threshold,

            'details': scores,

            'message': content[:100] + "..." if len(content) > 100 else content

        }

    

    def _check_logical_consistency(self, text):

        """Verifica consistencia lógica básica"""

        # Implementación minimalista - expandir con reglas específicas

        contradictions = [

            ("no", "sí"),

            ("nunca", "siempre"),

            ("todos", "ninguno")

        ]

        

        text_lower = text.lower()

        contradiction_count = 0

        

        for neg, pos in contradictions:

            if neg in text_lower and pos in text_lower:

                contradiction_count += 1

        

        return max(0.0, 1.0 - (contradiction_count * 0.3))

    

    def _check_temporal_coherence(self, text):

        """Verifica consistencia temporal"""

        # Implementación básica - expandir con análisis de secuencias temporales

        temporal_markers = ["antes", "después", "luego", "mientras", "cuando"]

        return 0.8 if any(marker in text.lower() for marker in temporal_markers) else 0.6

    

    def _check_semantic_density(self, text):

        """Verifica densidad de significado vs ruido"""

        words = re.findall(r'\b\w+\b', text.lower())

        if not words:

            return 0.0

        

        # Palabras vacías en español

        stop_words = {"el", "la", "los", "las", "un", "una", "unos", "unas", 

                     "y", "o", "pero", "porque", "que", "como", "con", "para"}

        

        meaningful_words = [w for w in words if w not in stop_words and len(w) > 2]

        density = len(meaningful_words) / len(words)

        

        return min(1.0, density * 1.5)  # Normalizar y amplificar
